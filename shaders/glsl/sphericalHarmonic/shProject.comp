#version 450

layout(std430, binding = 0) buffer SHCoefficientOut {
	vec4 shCoefficientOut[ ];
};

layout (binding = 1) uniform samplerCube inputImgCube;

layout (local_size_x = 16, local_size_y = 1, local_size_z = 1) in;

layout (binding = 2) uniform UBO 
{
	vec4  random[4048];//max 40000 sample
	vec4  controlP;//x:band y:sampleNum
} params;

#define PI 3.14159265358979
#define kCacheSize 13
//0！ 1！ 2！...
int Factorial(int x)
{
	const int factorial_cache[kCacheSize]={1,1,2,6,24,120,720,5040,40320, 362880, 3628800, 39916800, 479001600};
	if(x<kCacheSize)
	{
		return factorial_cache[x];
	}
	else
	{
        int s = factorial_cache[kCacheSize-1];
		for(int n = kCacheSize; n<=x; n++)
	    {
			s *= n;
		}
		return s;
	}
}

//legendre polynomial
//x = cos(theta)
float P(int l, int m, float x)
{
    float pmm = 1.f;//l==m
	if(m>0)
	{
		float somx2 = sqrt((1.0-x)*(1.0+x));
		float fact = 1.f;
		for(int i=0;i<=m;i++)
		{
			pmm *= (-fact)*somx2;
			fact += 2.f;
		}
	}
	if(l == m)return pmm;
	float pmmp1 = x*(2.0*m+1.0)*pmm;//l==m+1
	if(l==m+1)return pmmp1;
	float pll = 0.0;
	for(int ll=m+2;ll<=l;ll++)//ll:temp l
	{
		pll = ((2.0*ll-1.0)*x*pmmp1-(ll+m-1.0)*pmm)/(ll-m);
		pmm = pmmp1;
		pmmp1 = pll;
	}
	return pll;
}

//scale coefficient
//input：m > 0
float K(int l, int m)
{
	float temp = ((2.0*l+1.0)*Factorial(l-m))/(4.0*PI*Factorial(l+m));
	return sqrt(temp);
}

//l is band
//m in the range [-l,...l]
//theta in the range [0, pi]
//phi in the range [0, 2pi]
float SH(int l, int m, float theta, float phi)
{
	float sqrt2 = sqrt(2.0);
	if(m==0)return K(l,0)*P(l,0,cos(theta));
	else if(m>0) return sqrt2*K(l,m)*cos(m*phi)*P(l,m,cos(theta));
	else return sqrt2*K(l,-m)*sin(-m*phi)*P(l,-m,cos(theta));
}

void GetFromIndex(int n_band, int index, inout int l, inout int m)
{
	int tl, tm;
	for(tl=0; tl<n_band;tl++)
	{
		for(tm=-tl;tm<=tl;tm++)
		{
			int tIndex=tl*(tl+1)+tm;
			if(tIndex == index)
			{
				l=tl;
				m=tm;
				return;
			}
		}
	}
	return;
}

void main() 
{
	int id = int(gl_GlobalInvocationID.x);
    int n_band = int(params.controlP.x);
	int n_samples = int(params.controlP.y);
	int n_coeff = n_band*n_band;
	if(id < n_coeff)
	{
        vec3 shCoefficient= vec3(0,0,0);
		int l,m;
		GetFromIndex(n_band, id, l, m);
		for(int i=0;i<n_samples;i++)
		{
			float r1 = params.random[i/2][i%2*2];
			float r2 = params.random[i/2][i%2*2+1];
			float theta = 2.0 * acos(sqrt(1.0-r1));
			float phi = 2.0 * PI * r2;
			vec3 dir = vec3(sin(theta)*cos(phi),sin(theta)*sin(phi),cos(theta));
			//dir.xy *= -1;
			dir.yz = dir.zy;
            vec3 sampleColor = texture(inputImgCube, dir).rgb;		
		    shCoefficient.xyz += sampleColor * SH(l,m,theta,phi);
		}
		shCoefficient.xyz = shCoefficient.xyz * (4 * PI / n_samples);
		shCoefficientOut[id].xyz = shCoefficient.xyz;
	}
}