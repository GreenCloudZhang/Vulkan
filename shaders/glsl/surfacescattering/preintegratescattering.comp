#version 450

layout (local_size_x = 16, local_size_y = 16) in;

layout (binding = 0) uniform UBO 
{
	vec4 d_steps;//xyz: d  w:integrate steps
	vec4 texSize;//1/w, 1/h, w, h
} params;

layout (binding = 1, rgba8) uniform image2D resultImage;

#define PI_HALF 1.5707963
#define EPSILON 0.000001

void CalcStep(float ndotl, float sint, float curv, float x, inout vec3 a, inout vec3 rd)
{
	float cosx=cos(x);
	float sinx=sin(x);

	float costx = max(ndotl*cosx-sint*sinx, 0);//cos(t+x)
    float sinx_half = sin(x/2);
	float cosx_half = cos(x/2);
	if(curv<EPSILON)
	{
		rd=vec3(0,0,0);
		a=vec3(0,0,0);
	}
	else
	{
		float r = 1.0/curv;
		vec3 exponent = -abs(vec3(2*sinx_half)/(params.d_steps.xyz*curv));
		rd = (exp(exponent)+exp(exponent/3.0))*r*cosx_half/(8.0*params.d_steps.xyz);//Integral molecule,  GAUSSIAN SIMILAR DIFFUSION PROFILE
		a = costx * rd;//Integral denominator   F(a)/F(rd)
	}
}

void main() 
{
	uvec3 id = gl_GlobalInvocationID.xyz; 
    float w=params.texSize.z;
	float h=params.texSize.w;
	float curv=float((id.y+0.5f)/h);
	float ndotl=-1.0+2.0*(id.x+0.5)/w;
	float sint = sqrt(1.0-ndotl*ndotl);

	vec3 res_a=vec3(0);
	vec3 res_rd=vec3(0);
    
	vec3 a_prev;
	vec3 a;
    vec3 rd_prev;
	vec3 rd;
	CalcStep(ndotl, sint, curv, -PI_HALF, a_prev, rd_prev);

    float x = -PI_HALF+params.d_steps.w;
	while(x < PI_HALF)
	{
		CalcStep(ndotl, sint, curv, x, a, rd);
		res_a += (a_prev+a)*params.d_steps.w/2.0;//average of a_prev + a 
		res_rd += (rd_prev + rd)*params.d_steps.w/2.0;
		a_prev = a;
		rd_prev = rd;
		x+=params.d_steps.w;
	}
	vec3 res;
	if(res_rd.x <EPSILON && res_rd.y <EPSILON && res_rd.z <EPSILON)
	{
		res = vec3(ndotl, ndotl, ndotl);//denominator = 0
	}
	else{
		res = res_a/res_rd;
	}

    imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(res, 1.0));
}